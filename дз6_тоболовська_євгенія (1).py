# -*- coding: utf-8 -*-
"""ДЗ6_Тоболовська Євгенія.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17vQub4IxI6RIkUFlWITK3SVZWjDnAl7e

Завдання 1
"""

import networkx as nx
import matplotlib.pyplot as plt

# Ініціалізація направленого графа
G = nx.DiGraph()

# Додавання вершин (зупинок) з додатковими вершинами для створення більш складного графу
stops = ["Stop1", "Stop2", "Stop3", "Stop4", "Stop5", "Stop6", "Stop7"]
G.add_nodes_from(stops)

# Додавання ребер (шляхів між зупинками) з двосторонніми зв'язками та додатковими шляхами
edges = [
    ("Stop1", "Stop2"), ("Stop2", "Stop3"), ("Stop3", "Stop4"),
    ("Stop4", "Stop5"), ("Stop5", "Stop1"), ("Stop3", "Stop1"),
    ("Stop1", "Stop3"), ("Stop2", "Stop4"), ("Stop4", "Stop2"),
    ("Stop5", "Stop3"), ("Stop6", "Stop2"), ("Stop6", "Stop7"),
    ("Stop7", "Stop3"), ("Stop7", "Stop5")
]
G.add_edges_from(edges)

# Візуалізація оновленого графа
plt.figure(figsize=(10, 8))
nx.draw(G, with_labels=True, node_color='lightblue', node_size=2000,
        edge_color='grey', linewidths=1, font_size=15, arrows=True)
plt.title("Оновлена транспортна мережа міста")
plt.show()

# Аналіз основних характеристик оновленого графа
num_nodes = G.number_of_nodes()
num_edges = G.number_of_edges()
degrees = [G.degree(node) for node in G.nodes()]

# Виведення результатів аналізу оновленого графа
print("Кількість вершин:", num_nodes)
print("Кількість ребер:", num_edges)
print("Ступені вершин:", degrees)

"""Завдання 2

Реалізація DFS (Пошук у глибину)
"""

def dfs(graph, start, target, path=[], visited=set()):
    path = path + [start]
    visited.add(start)
    if start == target:
        return [path]
    paths = []
    for neighbor in graph.neighbors(start):
        if neighbor not in visited:
            newpaths = dfs(graph, neighbor, target, path, visited)
            for newpath in newpaths:
                paths.append(newpath)
    return paths

"""Реалізація BFS (Пошук у ширину)"""

from collections import deque

def bfs(graph, start, target):
    queue = deque([(start, [start])])
    visited = set()
    paths = []
    while queue:
        (vertex, path) = queue.popleft()
        visited.add(vertex)
        for next in set(graph.neighbors(vertex)) - set(path):
            if next == target:
                paths.append(path + [next])
            else:
                queue.append((next, path + [next]))
    return paths

"""Тепер застосую ці функції до графу, створеного в попередньому завданні, щоб знайти всі шляхи від "Stop1" до "Stop5":"""

# Переконаймося, що граф `G` вже створений і містить відповідні вершини та ребра

# Знаходимо всі шляхи за допомогою DFS
dfs_paths = dfs(G, "Stop1", "Stop5")

# Знаходимо всі шляхи за допомогою BFS
bfs_paths = bfs(G, "Stop1", "Stop5")

# Виведення результатів
print("DFS paths from Stop1 to Stop5:", dfs_paths)
print("BFS paths from Stop1 to Stop5:", bfs_paths)

"""Завдання 3"""

def dijkstra(graph, start):
    # Ініціалізація відстаней: спочатку всі відстані - нескінченність, крім початкової вершини
    distances = {vertex: float('infinity') for vertex in graph.nodes}
    distances[start] = 0

    # Ініціалізація попередників
    predecessors = {vertex: None for vertex in graph.nodes}

    # Невідвідані вершини
    unvisited = set(graph.nodes)

    while unvisited:
        # Вибір вершини з найменшою відстанню
        current_vertex = min(unvisited, key=lambda vertex: distances[vertex])
        unvisited.remove(current_vertex)

        # Оновлення відстаней для сусідів поточної вершини
        for neighbour in graph.neighbors(current_vertex):
            edge_weight = graph[current_vertex][neighbour]['weight']
            alternative_route = distances[current_vertex] + edge_weight

            # Якщо знайдено коротший шлях, оновлюємо відстань та попередника
            if alternative_route < distances[neighbour]:
                distances[neighbour] = alternative_route
                predecessors[neighbour] = current_vertex

    return distances, predecessors

# Додавання ваг до ребер графа
weights = {("Stop1", "Stop2"): 5, ("Stop2", "Stop3"): 6, ("Stop3", "Stop4"): 4,
           ("Stop4", "Stop5"): 7, ("Stop5", "Stop1"): 3, ("Stop3", "Stop1"): 2}

G = nx.DiGraph()
G.add_weighted_edges_from([(edge[0], edge[1], weight) for edge, weight in weights.items()])

# Застосування алгоритму Дейкстри
distances, predecessors = dijkstra(G, 'Stop1')

# Виведення результатів
for target, distance in distances.items():
    print(f"Відстань від Stop1 до {target} становить {distance}")